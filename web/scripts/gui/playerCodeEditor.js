// Generated by CoffeeScript 1.8.0
(function() {
  var jQuerySelectorEscapedString, _base,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if ((_base = String.prototype).startsWith == null) {
    _base.startsWith = function(str) {
      return this.lastIndexOf(str, 0) === 0;
    };
  }

  jQuerySelectorEscapedString = function(str) {
    return str.replace(/[^a-z0-9_]/gi, '\\$&');
  };

  window.EditorManager = (function() {

    /*
        Manages the code editor.
     */
    function EditorManager(editorDivId, editorConfig, codeConfig) {
      this.editorDivId = editorDivId;
      this.editorConfig = editorConfig;
      this.codeConfig = codeConfig;
      this.onGoingTouchIndexByID = __bind(this.onGoingTouchIndexByID, this);
      this.handleTouchCancel = __bind(this.handleTouchCancel, this);
      this.handleTouchEnd = __bind(this.handleTouchEnd, this);
      this.handleTouchMove = __bind(this.handleTouchMove, this);
      this.handleTouchStart = __bind(this.handleTouchStart, this);
      this.onEditorClick = __bind(this.onEditorClick, this);
      this.onEditorCursorMove = __bind(this.onEditorCursorMove, this);
      this.moveEditorButtons = __bind(this.moveEditorButtons, this);
      this.scan = __bind(this.scan, this);
      this.onStudentCodeChange = __bind(this.onStudentCodeChange, this);
      this.resetEditor = __bind(this.resetEditor, this);
      this.acelne = null;
      this.poffset = 0;
      this.onStudentCodeChangeCallback = null;
      this.commands = this.editorConfig.commands;
      this.setUpEditor();
      return;
    }

    EditorManager.prototype.getStudentCode = function() {
      return this.editor.getStudentCode();
    };

    EditorManager.prototype.setUpEditor = function() {

      /*
          Builds the HTML for, and sets up the functionality of,
          the player code editor.
       */
      var buttonField, d, editorDiv, u, x;
      editorDiv = $("#" + this.editorDivId);
      editorDiv.append('<div id="ace-editor"></div>');
      this.acelne = document.createElement("div");
      $(this.acelne).append('<div id="parameter-pop-up" class="pop-up-container"></div>');
      if (this.editorConfig.buttons.length !== 0) {
        buttonField = $('<div>', {
          id: 'buttons'
        });
        if ($.inArray('insertButtons', this.editorConfig.buttons) !== -1) {
          buttonField.append($('<div>', {
            id: 'insertButtons'
          }).get(0));
        }
        editorDiv.append(buttonField.get(0));
      }
      if ($.inArray('switchUp', this.editorConfig.buttons) !== -1) {
        this.switchUpImg = 'img/interface/ua-usable.png';
      } else {
        this.switchUpImg = 'img/interface/ua.png';
      }
      if ($.inArray('switchDown', this.editorConfig.buttons) !== -1) {
        this.switchDownImg = 'img/codeIn/da-usable.png';
      } else {
        this.switchDownImg = 'img/codeIn/da.png';
      }
      if ($.inArray('deleteLine', this.editorConfig.buttons) !== -1) {
        this.deleteImg = 'img/codeIn/cx-usable.png';
      } else {
        this.deleteImg = 'img/codeIn/cx.png';
      }
      this.interpreter = new CodeInterpreter(this.commands);
      this.editor = new PlayerCodeEditor('ace-editor', this.commands, this.codeConfig.initial, this.codeConfig.show, this.codeConfig.prefix, this.codeConfig.postfix, this.codeConfig.hiddenPostFix, this.editorConfig.freeformEditting, this.interpreter);
      x = document.createElement("img");
      $(x).attr({
        "src": "" + this.deleteImg,
        "class": "ace_xbutton"
      });
      u = document.createElement("img");
      $(u).attr({
        "src": "" + this.switchUpImg,
        "class": "ace_uparrow"
      });
      d = document.createElement("img");
      $(d).attr({
        "src": "" + this.switchDownImg,
        "class": "ace_downarrow"
      });
      $(this.acelne).append(u);
      $(this.acelne).append(x);
      $(this.acelne).append(d);
      $(this.acelne).attr({
        "id": "acelne"
      });
      $(this.acelne).css({
        "display": "block"
      });
      $('.ace_editor').append(this.acelne);
      $(".ace_scrollbar").scroll((function(_this) {
        return function() {
          return _this.moveEditorButtons();
        };
      })(this));
      this.setUpInsertButtons();
      this.addEventListeners();
      this.onStudentCodeChange();
      this.moveEditorButtonDelay = 30;
      setTimeout(this.moveEditorButtons, this.moveEditorButtonDelay);
    };

    EditorManager.prototype.setUpInsertButtons = function() {

      /*
          Inserts a button for each command of the game to the html field
          with the id of 'insertButtons'.
       */
      var button, buttonField, buttons, codeEditor, command, funct, line, lineText, maxUses, _i, _len, _ref;
      if ($.inArray('insertButtons', this.editorConfig.buttons) === -1) {
        return;
      }
      buttonField = $('#insertButtons');
      buttons = [];
      if (this.commands.shorthand != null) {
        _ref = this.commands.shorthand;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          lineText = line;
          maxUses = 1;
          if (typeof line === "object") {
            if (line.line != null) {
              lineText = line.line;
            }
            if (line.maxUses != null) {
              maxUses = line.maxUses;
            }
          }
          command = {
            usesRemaining: maxUses,
            inputs: 0,
            maxUses: maxUses,
            rawText: true
          };
          this.commands[lineText] = command;
          this.editor.commands[lineText] = command;
        }
        delete this.commands.shorthand;
      }
      for (command in this.commands) {
        codeEditor = this.editor;
        if (this.commands[command].rawText != null) {
          line = command;
          funct = codeEditor.insertLine;
        } else {
          line = this.editor.createBlankFunctionHeader(command) + ';';
          funct = codeEditor.insertCommand;
        }
        button = $('<button>', {
          id: command,
          value: command,
          text: "" + line,
          title: this.toUsesRemainingText(maxUses, maxUses),
          click: function(e) {
            (codeEditor.button(codeEditor.usesCurrentRow(codeEditor.usesTextDocument(funct)))).call(codeEditor, codeEditor.createNamedArguments({
              line: e.currentTarget.value
            }));
            return false;
          }
        });
        buttons.push(button.get(0));
      }
      buttonField.append(buttons);
    };

    EditorManager.prototype.addEventListeners = function() {
      var addOurResize, ed, normalResize, updateMove;
      ed = this.editor;
      if ($.inArray('switchUp', this.editorConfig.buttons) !== -1) {
        $('.ace_uparrow').click(ed.button(ed.usesCurrentPosition(ed.switchUp)));
      }
      if ($.inArray('switchDown', this.editorConfig.buttons) !== -1) {
        $('.ace_downarrow').click(ed.button(ed.usesCurrentPosition(ed.switchDown)));
      }
      if ($.inArray('deleteLine', this.editorConfig.buttons) !== -1) {
        $('.ace_xbutton').click(ed.button(ed.usesTextDocument(ed.usesCurrentRow(ed.deleteLine))));
      }
      ed.onChangeListener(this.onStudentCodeChange);
      ed.onClickListener(this.onEditorClick);
      ed.onCursorMoveListener(this.onEditorCursorMove);
      updateMove = (function(_this) {
        return function() {
          setTimeout(_this.moveEditorButtons, _this.moveEditorButtonDelay);
        };
      })(this);
      ed.editSession.on('changeScrollTop', updateMove);
      normalResize = ed.editor.renderer.onResize.bind(ed.editor.renderer);
      addOurResize = function(force, gutterWidth, width, height) {
        normalResize(force, gutterWidth, width, height);
        updateMove();
      };
      ed.editor.renderer.onResize = addOurResize;
      ed.editor.setShowFoldWidgets(false);
      this.ongoingTouches = [];
      $('.ace_scroller').bind("touchstart", this.handleTouchStart);
      $('.ace_scroller').bind("touchend", this.handleTouchEnd);
      $('.ace_scroller').bind("touchcancel", this.handleTouchCancel);
      $('.ace_scroller').bind("touchleave", this.handleTouchEnd);
      $('.ace_scroller').bind("touchmove", this.handleTouchMove);
    };

    EditorManager.prototype.resetEditor = function() {
      (this.editor.button(this.editor.resetState))();
    };

    EditorManager.prototype.onStudentCodeChangeListener = function(onStudentCodeChangeCallback) {
      this.onStudentCodeChangeCallback = onStudentCodeChangeCallback;
    };

    EditorManager.prototype.onCommandValidation = function(onCommandRemainingValid) {
      this.onCommandRemainingValid = onCommandRemainingValid;
    };

    EditorManager.prototype.onStudentCodeChange = function(changeData) {

      /*
          When the student code changes, run it through the
          interpreter to figure out commands remaining.
       */
      if (this.editorConfig.freeformEditting) {
        if (this.scanTimer != null) {
          window.clearTimeout(this.scanTimer);
          this.scanTimer = null;
        }
        this.scanTimer = window.setTimeout(this.scan, 300);
      } else {

      }
      this.UpdateCommandsStatus(null);
      if (this.onStudentCodeChangeCallback != null) {
        this.onStudentCodeChangeCallback(changeData);
      }
    };

    EditorManager.prototype.scan = function() {
      var remaining;
      remaining = this.interpreter.scanText(this.editor.getStudentCode());
      this.UpdateCommandsStatus(remaining);
    };

    EditorManager.prototype.UpdateCommandsStatus = function(remaining) {

      /*
          Updates the number of commands remaining for each command.
       */
      var button, buttonField, command, line, roundtotenth, urlvalue, usesRemaining, valid;
      valid = true;
      buttonField = $('#insertButtons');
      for (command in this.commands) {
        button = buttonField.find("#" + (jQuerySelectorEscapedString(command)));
        if (this.commands[command].rawText != null) {
          line = command;
        } else {
          line = this.editor.createBlankFunctionHeader(command);
        }
        if (remaining !== null) {
          usesRemaining = remaining[command];
        } else {
          usesRemaining = this.commands[command]['usesRemaining'];
        }
        button.attr('title', this.toUsesRemainingText(usesRemaining, this.commands[command].maxUses));
        roundtotenth = usesRemaining / this.commands[command].maxUses;
        roundtotenth *= 10;
        roundtotenth = Math.round(roundtotenth);
        urlvalue = 'url("img/buttoncount/button' + roundtotenth + '.png")';
        button.css('background-image', urlvalue);
        button.css('background-size', '100%');
        if (usesRemaining <= 0) {
          button.attr('disabled', true);
          if (usesRemaining < 0) {
            valid = false;
          }
        } else {
          button.attr('disabled', false);
        }
        button.text("" + line);

        /*  *{usesRemaining}" */
      }
      if (typeof this.onCommandRemainingValid === "function") {
        this.onCommandRemainingValid(valid);
      }
    };

    EditorManager.prototype.toUsesRemainingText = function(usesRemaining, maxUses) {
      if (usesRemaining <= 0) {
        return 'Already used (delete the code line to re-use this button)';
      }
      if (usesRemaining === 1 && maxUses === 1) {
        return 'Can only appear once!';
      }
      if (usesRemaining === 1) {
        return 'Can only appear one more time!';
      }
      return "Can be used " + usesRemaining + " more times";
    };

    EditorManager.prototype.moveEditorButtons = function() {
      var aglh, aglw, highlighted_line_position, maxrows, row;
      row = this.editor.editor.getCursorPosition().row;
      maxrows = this.editor.editSession.getLength();
      aglw = $('.ace_gutter-layer').width();
      aglh = $('.ace_gutter-cell').height();

      /*
         ace_gutter-active-line refers to line highlighting in the game level code editor (look at ace.js)
       */
      highlighted_line_position = $('.ace_gutter-active-line').position();
      if (maxrows === row + 1) {
        $(".ace_downarrow").css({
          "display": "none"
        });
      } else {
        $(".ace_downarrow").css({
          "display": "block"
        });
      }
      $(this.acelne).css({
        "width": "15px",
        "max-height": aglh * 2.6,
        "z-index": 20,
        "position": "relative",
        "left": 0 + "px",
        "display": "block"
      });

      /*
          Fixing the "top" property by only setting it when highlighted_line_position is not null - temporary HACK HACK HACK!!!
          TODO: Why the top property is null and why we need this hack
          
          Update: Issue Fixed! error caused by remnant window resize eventlistener set in 
          playerCodeEditor.js line 213 function "AddEventListeners".
          The resize function will still be called when game finishes and highlighted_line_position variable
          no longer exists.
          Fixed at gameManager.js "GameManager.prototype.finishGame" function.
          Swapped in a dummy function for resize when game finishes.
       */

      $(this.acelne).css({
        "top": highlighted_line_position.top - aglh * 1.5 + "px"
      });

      this.poffset = $(".ace_scrollbar").scrollTop();
    };

    EditorManager.prototype.onEditorCursorMove = function(cursorEvent) {
      if (this.parameterPopUp === void 0) {
        this.parameterPopUp = $('#parameter-pop-up');
      }
      setTimeout(this.moveEditorButtons, this.moveEditorButtonDelay);
      this.parameterPopUp.hide();
    };

    EditorManager.prototype.onEditorClick = function(inBounds, clickEvent) {

      /*
          When the editor is clicked, we may or may not
          want to pop up a div for students to enter
          parameters into.
          Return true: continue event propogation
          Return false: stop event propogation
       */
      var button, codeParam, command, commandInfo, editorOffset, gutterOffset, i, id, line, manager, numberOfInputs, row, rowLength, _i, _ref;
      row = clickEvent.$pos.row;
      if (this.parameterPopUp === void 0) {
        this.parameterPopUp = $('#parameter-pop-up');
      }
      if (inBounds) {
        line = clickEvent.editor.getSession().getLine(row);
        rowLength = line.length;
        if (rowLength === 0) {
          this.parameterPopUp.hide();
          return true;
        }
        commandInfo = this.interpreter.scanCommand(line);
        if (commandInfo === null) {
          clickEvent.stopPropagation();
          return false;
        }
        command = commandInfo.command;
        if (command === null) {
          this.parameterPopUp.hide();
          return true;
        }
        numberOfInputs = this.commands[command]['inputs'];
        if (numberOfInputs === 0) {
          this.parameterPopUp.hide();
          return true;
        }
        this.parameterPopUp.empty();
        this.parameterPopUp.append('(');
        for (i = _i = 1; _i <= numberOfInputs; i = _i += 1) {
          id = "" + command + "-parameter-" + i;
          this.parameterPopUp.append("<input id='" + id + "' type='text' size='5' class='pop-up-inside'>");
          codeParam = commandInfo.parameters[i - 1];
          if (codeParam !== "__") {
            $("#" + id).val(codeParam);
          }
          if (i !== numberOfInputs) {
            this.parameterPopUp.append(',');
            $("#" + id).keypress(function(e) {
              if (e.which === 13) {
                setTimeout((function() {
                  $(e.currentTarget).next().focus();
                }), 0);
                return false;
              }
              return true;
            });
          } else {
            manager = this;
            $("#" + id).keypress(function(e) {
              if (e.which === 13) {
                setTimeout((function() {
                  manager.popUpEditLine(row, command);
                }), 0);
                return false;
              }
              return true;
            });
          }
        }
        this.parameterPopUp.append(')');
        button = $('<button>', {
          id: 'editLine',
          text: 'Ok',
          "class": 'pop-up-inside',
          click: this.popUpEditLine.bind(this, row, command)
        });
        this.parameterPopUp.append(button.get(0));
        editorOffset = $('#ace-editor').position();
        gutterOffset = this.editor.editor.renderer.$gutterLayer.gutterWidth + ((_ref = this.editor.editor.renderer.$gutterLayer.$padding) != null ? _ref.left : void 0);
        this.parameterPopUp.css('top', "12px");
        this.parameterPopUp.css('left', gutterOffset + 5);
        this.parameterPopUp.mousedown(function(mousedownEvent) {
          mousedownEvent.stopPropagation();
        });
        this.parameterPopUp.show();
        setTimeout((function() {
          $("#" + command + "-parameter-" + 1).focus();
        }), 0);
        clickEvent.stopPropagation();
        return false;
      } else {
        this.parameterPopUp.hide();
      }
      return true;
    };

    EditorManager.prototype.popUpEditLine = function(row, command) {
      var ed, i, line, _i, _ref;
      if (this.parameterPopUp === void 0) {
        this.parameterPopUp = $('#parameter-pop-up');
      }
      line = "" + command + "(";
      for (i = _i = 1, _ref = this.commands[command]['inputs']; _i <= _ref; i = _i += 1) {
        line += $("#parameter-pop-up #" + command + "-parameter-" + i).val();
        if (i !== this.commands[command]['inputs']) {
          line += ', ';
        }
      }
      line += ');';
      ed = this.editor;
      (ed.button(ed.usesTextDocument(ed.editLine))).call(ed, ed.createNamedArguments({
        newLine: line,
        editRow: row
      }));
      this.parameterPopUp.hide();
    };

    EditorManager.prototype.editorGoToLine = function(row) {
      this.editor.gotoLine(row);
    };

    EditorManager.prototype.handleTouchStart = function(evt) {
      var touch, _i, _len, _ref;
      _ref = evt.originalEvent.changedTouches;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        touch = _ref[_i];
        this.ongoingTouches.push(touch);
      }
    };

    EditorManager.prototype.handleTouchMove = function(evt) {
      var horizontalDistance, id, touch, touches, verticalDistance, _i, _len;
      evt.preventDefault();
      touches = evt.originalEvent.changedTouches;
      for (_i = 0, _len = touches.length; _i < _len; _i++) {
        touch = touches[_i];
        id = this.onGoingTouchIndexByID(touch.identifier);
        verticalDistance = this.ongoingTouches[id].pageY - touch.pageY;
        horizontalDistance = this.ongoingTouches[id].pageX - touch.pageX;
        this.editor.editor.renderer.scrollBy(horizontalDistance, verticalDistance);
        this.ongoingTouches.splice(id, 1, touch);
      }
    };

    EditorManager.prototype.handleTouchEnd = function(evt) {
      var horizontalDistance, id, touch, touches, verticalDistance, _i, _len;
      touches = evt.originalEvent.changedTouches;
      for (_i = 0, _len = touches.length; _i < _len; _i++) {
        touch = touches[_i];
        id = this.onGoingTouchIndexByID(touch.identifier);
        verticalDistance = this.ongoingTouches[id].pageY - touch.pageY;
        horizontalDistance = this.ongoingTouches[id].pageX - touch.pageX;
        this.editor.editor.renderer.scrollBy(horizontalDistance, verticalDistance);
        this.ongoingTouches.splice(id, 1);
      }
    };

    EditorManager.prototype.handleTouchCancel = function(evt) {
      var id, touch, touches, _i, _len;
      touches = evt.originalEvent.changedTouches;
      for (_i = 0, _len = touches.length; _i < _len; _i++) {
        touch = touches[_i];
        id = this.onGoingTouchIndexByID(touch.identifier);
        this.ongoingTouches.splice(id, 1);
      }
    };

    EditorManager.prototype.onGoingTouchIndexByID = function(idToFind) {
      var i, id, _i, _ref;
      for (i = _i = 0, _ref = this.ongoingTouches.length; _i < _ref; i = _i += 1) {
        id = this.ongoingTouches[i].identifier;
        if (id === i) {
          return i;
        }
      }
      return -1;
    };

    return EditorManager;

  })();

  window.PlayerCodeEditor = (function() {

    /*
        Creates and provides functionality for an Ace editor representing player's code.
     */
    function PlayerCodeEditor(editorDivId, commands, initialText, wrapCode, codePrefix, codeSuffix, hiddenSuffix, freeEdit, interpreter) {
      this.editorDivId = editorDivId;
      this.commands = commands;
      this.initialText = initialText;
      this.wrapCode = wrapCode;
      this.codePrefix = codePrefix;
      this.codeSuffix = codeSuffix;
      this.hiddenSuffix = hiddenSuffix;
      this.freeEdit = freeEdit;
      this.interpreter = interpreter;
      this.reIndentCode = __bind(this.reIndentCode, this);
      this.onChange = __bind(this.onChange, this);

      /*
          Sets internal variables, the default text and buttons
          and their event handlers.
       */
      this.editor = ace.edit(this.editorDivId);
      window.dbgAce = this.editor;
      this.editSession = this.editor.getSession();
      this.editSession.setMode('ace/mode/java');
      this.editSession.setUseSoftTabs(true);
      this.editor.setReadOnly(!this.freeEdit);
      if (!this.freeEdit) {
        $("#" + this.editorDivId + " textarea").attr("readonly", "readonly");
      }
      this.codePrefixLength = 0;
      this.codeSuffixLength = 0;
      if (this.wrapCode === true) {
        if (this.codePrefix !== "") {
          this.codeText = this.codePrefix + this.initialText;
          this.codePrefixLength = this.codePrefix.split('\n').length - 1;
        }
        if (this.codeSuffix !== "") {
          this.codeText += '\n' + this.codeSuffix;
          this.codeSuffixLength = this.codeSuffix.split('\n').length - 1 + 1;
        }
      } else {
        this.codePrefix = "";
        this.codeSuffix = "";
        this.codeText = this.initialText;
      }
      this.enableKeyboardShortcuts();
      this.resetState();
      this.onChangeCallback = null;
      this.editor.on('change', this.onChange);
      return;
    }

    PlayerCodeEditor.prototype.getStudentCode = function() {
      var code;
      code = this.editor.getValue();
      if (this.hiddenSuffix != null) {
        code += '\n' + this.hiddenSuffix;
      }
      return code;
    };

    PlayerCodeEditor.prototype.gotoLine = function(row) {
      var column;
      column = this.editor.getCursorPosition().column;
      this.editor.gotoLine(row, column, true);
    };

    PlayerCodeEditor.prototype.enableKeyboardShortcuts = function() {

      /*
          This usually enables keyboard shortcuts.
          That said, it currently does nothing as those keyboard
          shortcuts ignore prefix / suffix length and we effectively
          have to over-write them with our own.
       */
      this.editor.commands.commands.movelinesup['readOnly'] = true;
      this.editor.commands.commands.movelinesdown['readOnly'] = true;
    };

    PlayerCodeEditor.prototype.disableKeyboardShorcuts = function() {
      this.editor.commands.commands.movelinesup['readOnly'] = false;
      this.editor.commands.commands.movelinesdown['readOnly'] = false;
    };

    PlayerCodeEditor.prototype.onChangeListener = function(onChangeCallback) {
      this.onChangeCallback = onChangeCallback;
    };

    PlayerCodeEditor.prototype.onChange = function(changeData) {
      if (this.reindentTimer != null) {
        window.clearTimeout(this.reindentTimer);
        this.reindentTimer = null;
      }
      if (!this.reIndenting) {
        window.setTimeout(this.reIndentCode, 500);
      }
      if (this.onChangeCallback !== null) {
        this.onChangeCallback(changeData);
      }
    };

    PlayerCodeEditor.prototype.onClickListener = function(callback) {
      this.editor.on('click', ((function(_this) {
        return function(clickEvent) {
          var inBounds;
          inBounds = true;
          if (clickEvent.$pos.row < _this.codePrefixLength || clickEvent.$pos.row >= _this.editSession.getLength() - _this.codeSuffixLength) {
            inBounds = false;
          }
          return callback(inBounds, clickEvent);
        };
      })(this)));
    };

    PlayerCodeEditor.prototype.onCursorMoveListener = function(callback) {
      this.editor.on('changeSelection', callback);
    };

    PlayerCodeEditor.prototype.switchUp = function(_arg) {
      var currentColumn, currentRow, maxRow;
      currentRow = _arg.currentRow, currentColumn = _arg.currentColumn;
      maxRow = this.editSession.getLength();
      if (currentRow - 1 < this.codePrefixLength || currentRow >= maxRow - this.codeSuffixLength) {
        return;
      }
      if (currentRow > 0) {
        this.editSession.moveLinesUp(currentRow, currentRow);
        this.editor.gotoLine(currentRow, currentColumn, false);
      }
    };

    PlayerCodeEditor.prototype.switchDown = function(_arg) {
      var currentColumn, currentRow, maxRow;
      currentRow = _arg.currentRow, currentColumn = _arg.currentColumn;
      maxRow = this.editSession.getLength();
      if (currentRow + 1 >= maxRow - this.codeSuffixLength || currentRow < this.codePrefixLength) {
        return;
      }
      if (currentRow < maxRow - 1) {
        this.editSession.moveLinesDown(currentRow, currentRow);
        this.editor.gotoLine(currentRow + 2, currentColumn, false);
      }
    };

    PlayerCodeEditor.prototype.deleteLine = function(_arg) {
      var command, currentRow, line, maxRow, text;
      text = _arg.text, currentRow = _arg.currentRow;
      maxRow = this.editSession.getLength();
      if (currentRow >= maxRow - this.codeSuffixLength || currentRow < this.codePrefixLength) {
        return;
      }
      line = text.getLine(currentRow);
      if (this.commands.hasOwnProperty(line.trim())) {
        this.commands[line.trim()]['usesRemaining']++;
      } else {
        command = this.interpreter.identifyCommand(line);
        if (command != null) {
          this.commands[command]['usesRemaining']++;
        }
      }
      if (text.getLength() === 1) {
        text.insertLines(currentRow + 1, ["\n"]);
        text.removeNewLine(currentRow);
      }
      text.removeLines(currentRow, currentRow);
    };

    PlayerCodeEditor.prototype.insertCommand = function(_arg) {
      var currentRow, line, printLine, text;
      text = _arg.text, line = _arg.line, currentRow = _arg.currentRow;
      this.commands[line]['usesRemaining']--;
      printLine = (this.createBlankFunctionHeader(line)) + ';';
      this.insertLine({
        text: text,
        line: printLine,
        currentRow: currentRow
      });
    };

    PlayerCodeEditor.prototype.insertLine = function(_arg) {
      var currentLine, currentRow, cursorOffset, line, maxRow, text;
      text = _arg.text, line = _arg.line, currentRow = _arg.currentRow;
      maxRow = this.editSession.getLength();
      currentRow = Math.max(currentRow, this.codePrefixLength - 1);
      currentRow = Math.min(currentRow, maxRow - this.codeSuffixLength - 1);
      currentLine = text.getLine(currentRow);
      if (this.commands.hasOwnProperty(line)) {
        this.commands[line]['usesRemaining']--;
      }
      if (currentLine.trim() === "") {
        text.removeLines(currentRow, currentRow);
        text.insertLines(currentRow, [line]);
        cursorOffset = 1;
      } else {
        text.insertLines(currentRow + 1, [line]);
        cursorOffset = 2;
      }
      if (text.getLength() === 2 && text.getLine(currentRow) === "") {
        text.removeNewLine(currentRow);
      }
      this.editor.gotoLine(currentRow + cursorOffset, 0, false);
    };

    PlayerCodeEditor.prototype.editLine = function(_arg) {
      var editRow, maxRow, newLine, position, text;
      text = _arg.text, editRow = _arg.editRow, newLine = _arg.newLine;
      maxRow = this.editSession.getLength();
      if (editRow + 1 < this.codePrefixLength || editRow + 1 >= maxRow - (this.codeSuffixLength - 1)) {
        return;
      }
      position = this.editor.getCursorPosition();
      text.insertLines(editRow, [newLine]);
      text.removeLines(editRow + 1, editRow + 1);
      this.editor.moveCursorToPosition(position);
    };

    PlayerCodeEditor.prototype.resetState = function() {

      /*
          Resets the text displayed in the editor,
          the commands used counts, and other internal variables.
       */
      var command, name, _ref;
      this.editor.setValue(this.codeText);
      this.editor.clearSelection();
      this.editor.resize();
      this.reIndentCode();
      this.gotoLine(this.codePrefixLength + 1 + this.findFirstNonCommentLine(this.initialText));
      this.editor.renderer.scrollToRow(this.codePrefixLength);
      _ref = this.commands;
      for (name in _ref) {
        command = _ref[name];
        command['usesRemaining'] = command['maxUses'];
      }
    };

    PlayerCodeEditor.prototype.reIndentCode = function() {
      var currentIndent, currentRow, mode, position, text, thisLine, thisLineIndent, _i, _ref;
      this.reIndenting = true;
      position = this.editor.getCursorPosition();
      text = this.editSession.getDocument();
      mode = this.editSession.getMode();
      for (currentRow = _i = 0, _ref = this.editSession.getLength(); _i < _ref; currentRow = _i += 1) {
        if (currentRow === 0) {
          continue;
        }
        thisLineIndent = mode.getNextLineIndent(this.editSession.getState(currentRow - 1), this.editSession.getLine(currentRow - 1), this.editSession.getTabString());
        thisLine = this.editSession.getLine(currentRow);
        currentIndent = /^\s*/.exec(thisLine)[0];
        if (currentIndent !== thisLineIndent) {
          thisLine = thisLineIndent + thisLine.trim();
        }
        text.insertLines(currentRow, [thisLine]);
        text.removeLines(currentRow + 1, currentRow + 1);
        mode.autoOutdent(this.editSession.getState(currentRow), this.editSession, currentRow);
      }
      this.editor.moveCursorToPosition(position);
      this.editor.clearSelection();
      this.reIndenting = false;
    };

    PlayerCodeEditor.prototype.createBlankFunctionHeader = function(command) {

      /*
          Creates a function header with __ for parameters.
          eg go(__)
       */
      var i, numberOfInputs, underscoresForInputs, _i;
      numberOfInputs = this.commands[command]['inputs'];
      underscoresForInputs = "";
      for (i = _i = 1; _i <= numberOfInputs; i = _i += 1) {
        underscoresForInputs += '__';
        if (i !== numberOfInputs) {
          underscoresForInputs += ', ';
        }
      }
      return "" + command + "(" + underscoresForInputs + ")";
    };

    PlayerCodeEditor.prototype.button = function(func) {

      /*
          This is a wrapper for the functions which are tied to buttons.
          It restores focus to the editor after the button has been pressed.
       */
      var playerCodeEditor;
      playerCodeEditor = this;
      return function() {
        if (arguments.length !== 0 && playerCodeEditor.detectNamedArgument(arguments[0])) {
          func.apply(playerCodeEditor, arguments);
        } else {
          func.call(playerCodeEditor);
        }
        playerCodeEditor.reIndentCode();
        playerCodeEditor.editor.focus();
        return false;
      };
    };

    PlayerCodeEditor.prototype.usesCurrentRow = function(func) {

      /*
          This is a wrapper for the functions which need to know the current row.
          It retrieves the current row and passes it to the function.
       */
      var playerCodeEditor;
      playerCodeEditor = this;
      return function() {
        var currentRow;
        currentRow = playerCodeEditor.editor.getCursorPosition().row;
        this.addNamedArguments(arguments, {
          currentRow: currentRow
        });
        if (arguments.length !== 0 && playerCodeEditor.detectNamedArgument(arguments[0])) {
          func.apply(playerCodeEditor, arguments);
        } else {
          func.call(playerCodeEditor);
        }
        return false;
      };
    };

    PlayerCodeEditor.prototype.usesCurrentPosition = function(func) {

      /*
          This is a wrapper for the functions which need to know the cursor's row and column
          It retrieves the current row and the current column and passes them to the function.
       */
      var playerCodeEditor;
      playerCodeEditor = this;
      return function() {
        var cursorPosition;
        cursorPosition = playerCodeEditor.editor.getCursorPosition();
        this.addNamedArguments(arguments, {
          currentRow: cursorPosition.row,
          currentColumn: cursorPosition.column
        });
        if (arguments.length !== 0 && playerCodeEditor.detectNamedArgument(arguments[0])) {
          func.apply(playerCodeEditor, arguments);
        } else {
          func.call(playerCodeEditor);
        }
        return false;
      };
    };

    PlayerCodeEditor.prototype.usesTextDocument = function(func) {

      /*
          This is a wrapper for functions which edit the text in the editor directly.
          It gets a reference to the text and passes it to the function.
       */
      var playerCodeEditor;
      playerCodeEditor = this;
      return function() {
        var text;
        text = playerCodeEditor.editSession.getDocument();
        this.addNamedArguments(arguments, {
          text: text
        });
        if (arguments.length !== 0 && playerCodeEditor.detectNamedArgument(arguments[0])) {
          func.apply(playerCodeEditor, arguments);
        } else {
          func.call(playerCodeEditor);
        }
        return false;
      };
    };

    PlayerCodeEditor.prototype.addNamedArguments = function(originalArguments, argumentDictionary) {

      /*
          Adds the named arguments to the original arguments.
          Makes changes to originalArguments, returns nothing.
       */
      var argument, argumentFound;
      if (originalArguments.length === 0) {
        originalArguments[originalArguments.length++] = this.createNamedArguments(argumentDictionary);
      } else {
        argumentFound = false;
        for (argument in originalArguments) {
          if (this.detectNamedArgument(originalArguments[argument])) {
            $.extend(true, originalArguments[argument], argumentDictionary);
            argumentFound = true;
            break;
          }
        }
        if (!argumentFound) {
          originalArguments[originalArguments.length++] = this.createNamedArguments(argumentDictionary);
        }
      }
    };

    PlayerCodeEditor.prototype.createNamedArguments = function(argumentDictionary) {

      /*
          Takes in an object of key-value pairs,
          returns an object of the Named Arguments format.
       */
      argumentDictionary['namedArgumentsFlag'] = true;
      return argumentDictionary;
    };

    PlayerCodeEditor.prototype.detectNamedArgument = function(argument) {

      /*
          Returns whether or not the argument is of the namedArguments format.
       */
      if (argument === null) {
        return false;
      }
      if (typeof argument !== 'object') {
        return false;
      }
      if (!('namedArgumentsFlag' in argument)) {
        return false;
      }
      if (argument['namedArgumentsFlag'] !== true) {
        return false;
      }
      return true;
    };

    PlayerCodeEditor.prototype.findFirstNonCommentLine = function(src) {

      /*
          Returns the line numer of the first non-comment line.
          This is obviously not a complete parser so obscure edge cases are unsupported
          e.g. print("/*") would be mistaken for a multiline comment.
       */
      var count, countEndMLC, countStartMLC, inMLC, isSLC, line, lines, _i, _len, _ref;
      lines = src.split('\n');
      count = 0;
      inMLC = false;
      _ref = src.split('\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        count += 1;
        if (line.match(/^S*$/)) {
          continue;
        }
        isSLC = !!line.match(/^\s*\/\//);
        countStartMLC = line.split('/*').length - 1;
        countEndMLC = line.split('*/').length - 1;
        if (inMLC) {
          if (!isSLC) {
            inMLC = countStartMLC > countEndMLC;
          }
        } else {
          if (!isSLC && !(inMLC = countStartMLC > countEndMLC)) {
            break;
          }
        }
      }
      return count;
    };

    return PlayerCodeEditor;

  })();

}).call(this);
