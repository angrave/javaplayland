// Generated by CoffeeScript 1.8.0
(function() {
  window.CodeInterpreter = (function() {
  
	/**
	 * Parses the list of commands and determines
	 * the number of uses each one has remaining.
	 * @param commands the list of commands to interpret
	 */
    function CodeInterpreter(commands) {
      var command;
      this.commands = commands;
      this.buildNeededParsers();
      this.usesRemaining = {};
      for (command in this.commands) {
        this.usesRemaining[command] = this.commands[command]['maxUses'];
      }
      return;
    }

	/**
     * Builds the parsers needed by the scanText function.
	 * Uses the current list of commands.
	 */
    CodeInterpreter.prototype.buildNeededParsers = function() {
      var command;
      for (command in this.commands) {
        this.commands[command]['parser'] = {
          'exec': this.buildParser(command)
        };
      }
    };

	/**
	 * Identifies the command executed by the line.
	 * Returns null if no command is found.
	 * @param line the line to identify
	 * @return the identified command, null if none was found
	 */
    CodeInterpreter.prototype.identifyCommand = function(line) {
      var command, found;
      for (command in this.commands) {
        found = this.commands[command]['parser'].exec(line);
        if (found !== null) {
          return command;
        }
      }
      return null;
    };
	
	/**
	 * Scans the line for the command being used and
	 * determines its parameters
	 * @param line the line to scan for commands
	 * @return the command used and it's parameters
	 */
    CodeInterpreter.prototype.scanCommand = function(line) {
      var command, parameters, result;
      for (command in this.commands) {
        result = this.commands[command]['parser'].exec(line);
        if (result !== null) {
          parameters = this.processCommand(command, result[1]);
          return {
            "command": command,
            "parameters": parameters
          };
        }
      }
      return null;
    };
	
	/**
	 *
	 */
    CodeInterpreter.prototype.executeCommands = function(commandMap) {
      var commandCard, _i, _len, _ref;
      _ref = this.commandStack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        commandCard = _ref[_i];
        //highlight the line first, then display results
        commandMap.highlightCommand(commandCard.line);
        commandCard.parameters.push(commandCard.line);
        commandMap[commandCard.command].apply(commandMap, commandCard.parameters);
      }
      commandMap.finishedParsingStartGame();
    };
	
	/**
	 *  Scans the selected text and returns a dictionary
     *	which contains, for each command which which this
     *	interpretor was constructed, how many uses they have
     *	remaining.
	 * @param text the text to scan through
	 * @return the number of uses remaining for each command 
	 */
    CodeInterpreter.prototype.scanText = function(text) {
      var command, currentLine, parameters, result;
      this.commandStack = [];
      for (command in this.commands) {
        this.usesRemaining[command] = this.commands[command]['maxUses'];
      }
      currentLine = 1;
      while (text !== "") {
        result = null;
        for (command in this.commands) {
          result = this.commands[command]['parser'].exec(text);
          if (result !== null) {
            this.usesRemaining[command]--;
            parameters = this.processCommand(command, result[1]);
            this.commandStack.push({
              command: command,
              parameters: parameters,
              line: currentLine
            });
            break;
          }
        }
        if (result === null) {
          result = /^\s+/.exec(text);
        }
        if (result === null) {
          result = /^;/.exec(text);
        }
        if (result === null) {
          result = /^\/\/.*(?:\n || $)/.exec(text);
        }
        if (result === null) {
          result = /^\/\*(.*\n)*\*\//.exec(text);
        }
        if (result === null) {
          result = /^.*(?:\n || $)/.exec(text);
        }
        if (result === null) {
          if (text.charAt(0) === '\n') {
            currentLine++;
          }
          text = text.substring(1);
        } else {
          currentLine += result[0].replace(/[^\n]+/g, "").length;
          text = text.substring(result[0].length);
        }
      }
      return this.usesRemaining;
    };

	/**
	 * Processes a found command. 
	 * @param command the command to process
	 * @param innerText the text inside the command to process
	 * @return the list of parameters for the command
	 */
    CodeInterpreter.prototype.processCommand = function(command, innerText) {
      var parameters, result;
      if (typeof innerText === "undefined" || innerText === null || innerText === "") {
        return [];
      }
      parameters = [];
      while (innerText !== "") {
        result = null;
        if (result === null) {
          result = /^\s/.exec(innerText);
        }
        if (result === null) {
          result = /^(?:"(.*?)")|(?:'(.*?)')/.exec(innerText);
          if (result !== null) {
            if (result[1] !== null) {
              parameters.push(result[1]);
            } else {
              parameters.push(result[2]);
            }
          }
        }
        if (result === null) {
          result = /^(?:[^,]+)/.exec(innerText);
          if (result !== null) {
            parameters.push(result[0]);
          }
        }
        if (result === null) {
          innerText = innerText.substring(1);
        } else {
          innerText = innerText.substring(result[0].length);
        }
      }
      return parameters;
    };

	/**
	 * Creates a parser that will recognize the command.
     *    It will return an object of the form
     *    {
     *        '0': The matched string.
     *        '1': The inner parameters of the command.
     *    }
     *    or it will return null.
     *    The form of the return object is so that
     *    it will act somewhat like a RegExp object.
	 * @param command the command to build a parser for
	 * @return function representing the command parser
	 */
    CodeInterpreter.prototype.buildParser = function(command) {
	
      return function(text) {
        var commandIndex, commandMatch, commandMatched, continueMatch, innerEndIndex, innerStartIndex, openParenthesis, state, textIndex;
        textIndex = 0;
        commandIndex = 0;
        innerStartIndex = null;
        innerEndIndex = null;
        state = "beforeCommand";
        openParenthesis = 0;
        commandMatched = null;
        continueMatch = true;
        while (continueMatch) {
          if (textIndex > text.length) {
            continueMatch = false;
          }
          switch (state) {
            case "beforeCommand":
              switch (text.charAt(textIndex)) {
                case ' ':
                  break;
                case command.charAt(commandIndex):
                  state = "atCommand";
                  commandIndex++;
                  break;
                default:
                  commandMatch = false;
                  continueMatch = false;
              }
              break;
            case "atCommand":
              switch (text.charAt(textIndex)) {
                case ' ':
                  if (commandIndex !== command.length) {
                    commandMatch = false;
                    continueMatch = false;
                  }
                  break;
                case '(':
                  if (commandIndex === command.length) {
                    commandMatch = true;
                    innerStartIndex = textIndex + 1;
                    openParenthesis = 1;
                    state = "insideCommand";
                  } else {
                    commandMatch = false;
                    continueMatch = false;
                  }
                  break;
                case command.charAt(commandIndex):
                  commandIndex++;
                  break;
                default:
                  commandMatch = false;
                  continueMatch = false;
              }
              break;
            case "insideCommand":
              switch (text.charAt(textIndex)) {
                case '(':
                  openParenthesis++;
                  break;
                case ')':
                  openParenthesis--;
                  if (openParenthesis === 0) {
                    innerEndIndex = textIndex - 1;
                    continueMatch = false;
                  }
                  break;
                case '\n':
                  innerEndIndex = textIndex;
                  continueMatch = false;
              }
          }
          textIndex++;
        }
        if (!commandMatch) {
          return null;
        }
        return {
          '0': text.substring(0, textIndex),
          '1': text.substring(innerStartIndex, innerEndIndex + 1),
          'reason': ""
        };
      };
    };

    return CodeInterpreter;

  })();

}).call(this);
