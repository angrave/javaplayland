// Generated by CoffeeScript 1.8.0
(function() {
  var GridGameCommands, deepcopy,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof deepcopy === "undefined" || deepcopy === null) {
    deepcopy = function(src) {
      return $.extend(true, {}, src);
    };
  }

  window.GridGameState = (function() {
    var clockHandle;

    clockHandle = null;
	
    GridGameState.prototype.invalidParameterException = function(value) {
      this.name = 'invalidParameterException';
      this.value = value;
    };
	
	/**
	 * Sets up the game state for the GUI board displaying the users' 
	 * progress. It manages the game, its clock, and all other aspects.
	 * @param gameManager the game manager object
	 * @param waitForCode true if code has been input, false otherwise
	 * @return an initialized grid game state
	 */
    function GridGameState(gameManager, waitForCode) {
      var character, command, name, _i, _len, _ref, _ref1;
      this.gameManager = gameManager;
      this.stopGame = __bind(this.stopGame, this);
      this.protagonistFalls = __bind(this.protagonistFalls, this);
      this.gameLost = __bind(this.gameLost, this);
      this.gameWon = __bind(this.gameWon, this);
      this.clock = __bind(this.clock, this);
      this.cleanPrevHighlight = __bind(this.cleanPrevHighlight, this);
      this.highlightCommand = __bind(this.highlightCommand, this);
      this.gameConfig = deepcopy(this.gameManager.config.game);
      this.gameCommands = new GridGameCommands(this);
      this.visual = this.gameManager.visual;
      this.score = 0;
      this.stars = 0;
      this.protagonist = this.gameConfig.characters.protagonist;
      this.target = this.gameConfig.characters.gflag;
      this.tick = 0;
      this.tock = 0;
      this.waitTime = 8;
      this.speed = 30;
      this.highlightid = 0;
      _ref = this.gameConfig.characters;
      for (name in _ref) {
        character = _ref[name];
        if ((character.AI != null) && (character.moves != null)) {
          this._stand(character);
          _ref1 = character.AI.normal;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            command = _ref1[_i];
            this.executeAICommand(character, command);
          }
        }
      }
      if (clockHandle != null) {
        clearInterval(clockHandle);
      }
      clockHandle = setInterval(this.clock, 17);
      this.startedGame = false;
      this.waiting = false;
      if (!waitForCode) {
        this.start();
      }
      return;
    }
	
    GridGameState.prototype.getGameCommands = function() {
      return this.gameCommands;
    };
	
	/**
	 * Executes the AI command for the play character.
	 * @param character the character to move around
	 * @param command the command to execute on the character
	 */
    GridGameState.prototype.executeAICommand = function(character, command) {
      var arg, index, _i, _len, _ref;
      this.character = character;
      _ref = command["arguments"];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        arg = _ref[index];
        if (arg === "character" || arg === "protagonist") {
          command["arguments"][index] = this[arg];
        }
      }
      this[command.command].apply(this, command["arguments"]);
      this.character = null;
    };
	
	/**
	 * Moves the clock one tic forward, changing the 
	 * state of every character on the grid according the 
	 * command assigned to them if the game state is not waiting.
	 */
    GridGameState.prototype.clock = function() {
      var character, e, name, _ref, _ref1;
      if (this.startedGame === true) {
        if (this.tick % this.speed  === 0) {
          this.checkEvents();
          if (!this.waiting) {
            _ref = this.gameConfig.characters;
            for (name in _ref) {
              character = _ref[name];
              try {
                this.runCharacterCommand(character);
              } catch (_error) {
                e = _error;
                this.gameLost();
              }
            }
            this.waiting = true;
          } else {
            _ref1 = this.gameConfig.characters;
            for (name in _ref1) {
              character = _ref1[name];
              this.visual.changeState(character.index, 4);
            }
            this.waiting = false;
          }
        }
        if (!this.waiting && (this.tick - this.waitTime) % this.speed  === 0) {
          this.tick -= this.waitTime + 1;
        }
      }
      this.visual.getFrame(this.gameManager.config.visual, this.tock);
      this.tick++;
      this.tock++;
    };
	
	/**
	 * Runs the first command the character has available.
	 * Moves the editor selection down with the execution of each line.
	 * @param character the character to run commands for
	 */
    GridGameState.prototype.runCharacterCommand = function(character) {
      var aiCommand, command, result, _i, _j, _len, _len1, _ref, _ref1;
      if (character.moves == null) {
        return;
      }
      if (character.moves.length > 0) {
        command = character.moves.splice(0, 1)[0];
        if (command.line != null) {
          this.gameManager.codeEditor.editorGoToLine(command.line);
        }
        result = command.exec();
        if (character.AI != null) {
          if (!result.success) {
            if (character.AI.failed[command.key] != null) {
              _ref = character.AI.failed[command.key];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                aiCommand = _ref[_i];
                this.executeAICommand(character, aiCommand);
              }
            }
          }
        }
      }
      if (character === this.protagonist && character.moves.length === 0) {
        this.protagonistDoneMoving = true;
      }
      if ((character.AI != null) && character.moves.length === 0) {
        _ref1 = character.AI.normal;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          aiCommand = _ref1[_j];
          this.executeAICommand(character, aiCommand);
        }
      }
      if (result != null ? result.continueExecution : void 0) {
        this.runCharacterCommand(character);
      }
    };
	
	/**
	 * Leaves a trail marker for the character's movement at the 
	 * block located on the point (x,y) specified.
	 * @param placeTrail the point (x,y) to place the trail on
	 */
    GridGameState.prototype.leaveTrail = function(placeTrail) {
      var char;
      if ((placeTrail != null) && !this.protagonistDoneMoving) {
        char = this.gameManager.generateCharacter('trail', placeTrail.x, placeTrail.y, false);
        this.visual.pushCharacter(this.gameManager.config.visual, char.visual);
      }
    };

	/**
	 * Checks the list of events that occurred and triggers 
	 * any that did including victory or game loss.
	 */
    GridGameState.prototype.checkEvents = function() {
      var character, name, triggers, _ref;
      if (this.protagonist.x < 0 || this.protagonist.x >= this.gameManager.config.visual.grid.gridX || this.protagonist.y < 0 || this.protagonist.y >= this.gameManager.config.visual.grid.gridY) {
        this.protagonistFalls();
        this.cleanPrevHighlight();
      }
      triggers = {
        "victory": this.gameWon,
        "loss": this.gameLost,
        "fall": this.protagonistFalls
      };
      _ref = this.gameConfig.characters;
      for (name in _ref) {
        character = _ref[name];
        if (character === this.protagonist) {
          continue;
        }
        if (this.protagonist.x === character.x && this.protagonist.y === character.y) {
          if (character.trigger != null) {
            if (character.trigger !== "victory" || (character.trigger === "victory" && this.protagonistDoneMoving)) {
              this.cleanPrevHighlight();
              triggers[character.trigger]();
            }
          }
        }
      }
      if (this.protagonistDoneMoving && this.protagonist.moving) {
        this.visual.charAnimate(this.protagonist.index);
        this.protagonist.moving = false;
        this.cleanPrevHighlight();
        this.gameLost();
      }
    };

	/**
	 * Sets flags for starting the game,
	 * and character animation. 
	 */
    GridGameState.prototype.start = function() {
      if (this.protagonist.moves.length > 0) {
        this.visual.charAnimate(this.protagonist.index);
        this.protagonist.moving = true;
      }
      this.protagonistDoneMoving = false;
      this._stand(this.protagonist);
      this.startedGame = true;
    };

	/**
	 * Sets the given character into the standing
	 * state. If no character is specified, 
	 * the protagonist is the default. 
	 * @param character the character to stand up
	 */
    GridGameState.prototype._stand = function(character) {
      if (character == null) {
        character = this.protagonist;
      }
      character.moves.push({
        key: 'stand',
        exec: (function(char) {
          this.visual.changeState(char.index, 4);
          return {
            success: true,
            continueExecution: false
          };
        }).bind(this, character)
      });
    };
	
	/**
	 * Pushes the jump action to the list of character
	 * actions. and a success action to continue execution.
	 * @param character the character to have jump
	 * @param steps the number of steps the character has 
	 * @param line the line containing the command to execute
	 */
    GridGameState.prototype.jump = function(character, steps, line) {
      if (character == null) {
        character = this.protagonist;
      }
      if (character.moves.length > 0 && character.moves[character.moves.length - 1].key === 'stand') {
        character.moves.pop();
      }
      return character.moves.push({
        key: 'jumping',
        exec: (function(char) {
          var success;
          success = this._jump(char);
          return {
            success: success,
            continueExecution: false
          };
        }).bind(this, character)
      });
    };

	/**
	 * Moves the character the given number of steps given
	 * the line containing the command.
	 * @param character the character to have jump
	 * @param steps the number of steps the character has 
	 * @param line the line containing the command to execute
	 */
    GridGameState.prototype.move = function(character, steps, line) {
      if (character == null) {
        character = this.protagonist;
      }
      if (character.moves.length > 0 && character.moves[character.moves.length - 1].key === 'stand') {
        character.moves.pop();
      }
      character.moves.push({
        key: 'startMove',
        exec: (function(char, steps) {
          var success;
          success = this._move(char, steps);
          return {
            success: success,
            continueExecution: false
          };
        }).bind(this, character, steps),
        line: line
      });
    };

	/**
	 * Sends the fail alert for the given line to 
	 * stop in the editor. 
	 * @param line the line containing the failed command
	 */
    GridGameState.prototype.fail = function(line) {
      this.protagonist.moves.push({
        key: 'fail',
        exec: (function(char, steps) {
          this.protagonistFalls();
          return {
            success: true,
            continueExecution: false
          };
        }).bind(this, this.protagonist, 1),
        line: line
      });
    };

	/**
	 * Sets the character to the moving state, and moves
	 * one space on success. 
	 * @param character the character to start moving
	 */
    GridGameState.prototype._moving = function(character) {
      if (character == null) {
        character = this.protagonist;
      }
      character.moves.unshift({
        key: 'moving',
        exec: (function(char) {
          var success;
          success = this._move(char, 1);
          return {
            success: success,
            continueExecution: false
          };
        }).bind(this, character)
      });
    };
	
	/**
	 * Moves the character the given number of steps, and 
	 * changes the visual state accordingly.
	 * @param character the character to move
	 * @param steps the number of steps to take
	 */
    GridGameState.prototype._move = function(character, steps) {
      var hitEvent, i, moved, newx, newy, _i, _ref;
      if (character == null) {
        character = this.protagonist;
      }
      if (isNaN(steps)) {
        throw new this.invalidParameterException(steps);
      }
      for (i = _i = 1; _i < steps; i = _i += 1) {
        this._moving(character);
      }
      moved = false;
      _ref = this.computeStepInDirection(character.dir, character.x, character.y), newx = _ref[0], newy = _ref[1];
      hitEvent = this.checkCanMove(newx, newy, character);
      if (!hitEvent) {
        this.visual.changeState(character.index, character.dir);
        if (character === this.protagonist) {
          this.leaveTrail({
            'x': character.x,
            'y': character.y
          });
        }
        character.x = newx;
        character.y = newy;
        moved = true;
      } else {
        this.visual.changeState(character.index, 4);
      }
      return moved;
    };

	/**
	 * Jumps the character over the square ahead of it using
	 * two steps in the direction.
	 * @param character the character to jump
	 */
    GridGameState.prototype._jump = function(character) {
      var hitEvent, moved, newx, newy, xx, yy, _ref, _ref1;
      if (character == null) {
        character = this.protagonist;
      }
      moved = false;
      _ref = this.computeStepInDirection(character.dir, character.x, character.y), xx = _ref[0], yy = _ref[1];
      _ref1 = this.computeStepInDirection(character.dir, xx, yy), newx = _ref1[0], newy = _ref1[1];
      hitEvent = this.checkCanMove(newx, newy, character);
      if (!hitEvent) {
        this.visual.changeState(character.index, character.dir + 6);
        if (character === this.protagonist) {
          this.leaveTrail({
            xx: xx,
            yy: yy
          });
          this.leaveTrail({
            'x': character.x,
            'y': character.y
          });
        }
        character.x = newx;
        character.y = newy;
        moved = true;
      } else {
        this.visual.changeState(character.index, 4);
      }
      return moved;
    };

	/**
	 * Checks if the character can move to the new position.
	 * @param newX the new X position on the grid
	 * @param newY the new Y position on the grid
	 * @param character the character to move
	 * @return true if the character CAN'T move to
	 * the new position, false otherwise
	 */
    GridGameState.prototype.checkCanMove = function(newX, newY, character) {
      var name, otherCharacter, _ref, _ref1;
      if (character !== this.protagonist && (newX < 0 || newX >= this.gameManager.config.visual.grid.gridX || newY < 0 || newY >= this.gameManager.config.visual.grid.gridY)) {
        return true;
      }
      if (character.group != null) {
        _ref = this.gameConfig.characters;
        for (name in _ref) {
          otherCharacter = _ref[name];
          if (otherCharacter === character) {
            continue;
          }
          if (otherCharacter.blocks == null) {
            continue;
          }
          if (newX === otherCharacter.x && newY === otherCharacter.y && (_ref1 = character.group, __indexOf.call(otherCharacter.blocks, _ref1) >= 0)) {
            return true;
          }
        }
      }
      return false;
    };
	
	/**
	 * Turns the character in the given direction. 
	 * @param character the character to turn 
	 * @param direction the direction to turn the character in
	 * @param line the line containing the executed command
	 */
    GridGameState.prototype.turn = function(character, direction, line) {
      if (character == null) {
        character = this.protagonist;
      }
      if (character.moves.length > 0 && character.moves[character.moves.length - 1].key === 'stand') {
        character.moves.pop();
      }
      character.moves.push({
        key: 'turn',
        exec: (function(dir, char) {
          var continueExec;
          continueExec = this._turn(char, dir);
          return {
            success: true,
            continueExecution: continueExec
          };
        }).bind(this, direction, character),
        line: line
      });
      this._stand(character);
    };

	/**
	 * Adds a right turn to the list of character moves.
	 * @param character the character to move
	 * @param line the line containing the command to use
	 */
    GridGameState.prototype.turnRight = function(character, line) {
      if (character == null) {
        character = this.protagonist;
      }
      if (character.moves.length > 0 && character.moves[character.moves.length - 1].key === 'stand') {
        character.moves.pop();
      }
      character.moves.push({
        key: 'turn',
        exec: (function(char) {
          var continueExec;
          continueExec = this._turn(char, (char.dir + 1) % 4);
          return {
            success: true,
            continueExecution: continueExec
          };
        }).bind(this, character),
        line: line
      });
      this._stand(character);
    };

	/**
	 * Adds a left turn to the list of character moves.
	 * @param character the character to move
	 * @param line the line containing the command to use
	 */
    GridGameState.prototype.turnLeft = function(character, line) {
      if (character == null) {
        character = this.protagonist;
      }
      if (character.moves.length > 0 && character.moves[character.moves.length - 1].key === 'stand') {
        character.moves.pop();
      }
      character.moves.push({
        key: 'turn',
        exec: (function(char) {
          var continueExec;
          continueExec = this._turn(char, (char.dir + 3) % 4);
          return {
            success: true,
            continueExecution: continueExec
          };
        }).bind(this, character),
        line: line
      });
      this._stand(character);
    };

	/**
	 * Turns the character in the given direction.
	 * @param character the character to turn
	 * @param direction the direction to turn the character in
	 */
    GridGameState.prototype._turn = function(character, direction) {
      if (character == null) {
        character = this.protagonist;
      }
      if (character.dir === direction) {
        return true;
      } else {
        character.dir = direction;
        this.visual.charFace(character.index, character.dir);
        this.visual.changeState(character.index, 4);
      }
    };

	/**
	 * Stops the game and sends a trigger 
	 * using the score and stars collected. 
	 * Sends a "game won" message. 
	 */
    GridGameState.prototype.gameWon = function() {
      if (!this.startedGame) {
        return;
      }
      this.stopGame();
      this.stars = 1;
      this.score = 5;
      this.gameManager.gameWon(this.score, this.stars);
    };
	
	/**
	 * Stops the game and sends a trigger.
	 * Sends a "game lost" message. 
	 */
    GridGameState.prototype.gameLost = function() {
      if (!this.startedGame) {
        return;
      }
      this.stopGame();
      this.gameManager.gameLost();
    };
	
	/** 
	 * Called when the protagonist fails to make the 
	 * set of programmed moves. Changes game state and
	 * sends a loss message. 
	 */
    GridGameState.prototype.protagonistFalls = function() {
      var character, name, _ref;
      _ref = this.gameConfig.characters;
      for (name in _ref) {
        character = _ref[name];
        character.moves = null;
      }
      this.visual.changeState(this.protagonist.index, 5);
      setTimeout(this.gameLost, 680);
    };

    GridGameState.prototype.stopGame = function() {
      var character, name, _ref;
      this.startedGame = false;
      if (clockHandle != null) {
        clearInterval(clockHandle);
      }
      _ref = this.gameConfig.characters;
      for (name in _ref) {
        character = _ref[name];
        if (this.visual.getState(character.index) !== 5) {
          this.visual.changeState(character.index, 4);
        }
        character.moves = null;
      }
    };

    GridGameState.prototype.computeStepInDirection = function(direction, currentX, currentY) {
      var isEastOrWest, newx, newy, sign, _ref;
      _ref = [-1 + ((direction + 1) & 2), direction & 1], sign = _ref[0], isEastOrWest = _ref[1];
      newx = currentX + sign * isEastOrWest;
      newy = currentY + sign * (1 - isEastOrWest);
      return [newx, newy];
    };

    GridGameState.prototype.highlightCommand = function(startLine, endLine)
    {
      //Don't highlight regions or past end of the code (indicates library code)
      if(startLine != endLine)
      {
        return;
      }
      //HACK - ignore line numbers past the maximum line number in user code to
      //hopefully ignore most references to library code
      if(endLine > this.gameManager.codeEditor.editor.editSession.getLength())
      {
        return;
      }
      keystring = 'highlightCommand' + String(startLine);
      if(this.protagonist.moves.length === 0 || this.protagonist.moves[this.protagonist.moves.length-1].key != keystring)
      {
        this.protagonist.moves.push({
          key: keystring,
          exec: this._highlightLine.bind(this, startLine-1, startLine-1)
        });
      }
    };

    GridGameState.prototype._highlightLine = function(startLine, endLine)
    {
      this.cleanPrevHighlight()
      this.highlightid = this.gameManager.codeEditor.editor.editSession.highlightLines(startLine, endLine);
    };

    GridGameState.prototype.cleanPrevHighlight = function()
    {
      if(this.highlightid) {
        this.gameManager.codeEditor.editor.editSession.removeMarker(this.highlightid.id);
        this.highlightid = null;
      }
    };


    return GridGameState;

  })();

  GridGameCommands = (function() {
    function GridGameCommands(gameState) {
      this.gameState = gameState;
      this.mysteryMove = __bind(this.mysteryMove, this);
      this.mysteryGo = __bind(this.mysteryGo, this);
      this.goWest = __bind(this.goWest, this);
      this.goSouth = __bind(this.goSouth, this);
      this.goEast = __bind(this.goEast, this);
      this.goNorth = __bind(this.goNorth, this);
      this.jump = __bind(this.jump, this);
      this.turnAndGo = __bind(this.turnAndGo, this);
      this.turnLeft = __bind(this.turnLeft, this);
      this.turnRight = __bind(this.turnRight, this);
      this.turn = __bind(this.turn, this);
      this.go = __bind(this.go, this);
      return;
    }

    GridGameCommands.prototype.finishedParsingStartGame = function() {
      this.gameState.start();
    };

    GridGameCommands.prototype.highlightCommand = function(linenum) {
      //Subtract 1 because of different starting convenions
      this.gameState.highlightCommand(linenum, linenum);
    }

    GridGameCommands.prototype.go = function(steps, line) {
      if (steps === void 0) {
        steps = 1;
      }
      steps = parseInt(steps.toString(), 10);
      if (line === void 0) {
        line = steps;
        steps = 1;
      }
      if (isNaN(steps)) {
        this.gameState.fail(line);
      } else {
        this.gameState.move(this.gameState.protagonist, steps, line);
      }
    };

    GridGameCommands.prototype.turn = function(dir, line) {
      var d;
      if (line == null) {
        line = 0;
      }
      if (dir === void 0) {
        return;
      }
      d = $.inArray(dir, ['N', 'E', 'S', 'W']);
      if (d >= 0) {
        this.gameState.turn(this.gameState.protagonist, d, line);
      } else {
        d = $.inArray(dir, ['North', 'East', 'South', 'West']);
        if (d >= 0) {
          this.gameState.turn(this.gameState.protagonist, d, line);
        } else if (!isNaN(d)) {
          this.gameState.turn(this.gameState.protagonist, (4 + dir % 4) % 4, line);
        }
      }
    };

    GridGameCommands.prototype.turnRight = function(line) {
      this.gameState.turnRight(this.gameState.protagonist, line);
    };

    GridGameCommands.prototype.turnLeft = function(line) {
      this.gameState.turnLeft(this.gameState.protagonist, line);
    };
	
	/**
	 * Turns the game character in the given direction 
	 * ('N','S','E','W') and takes the number of steps in that
	 * direction.
	 * @param direction the direction to turn
	 * @param steps the number of steps to takes
	 * @param line 
	 */
    GridGameCommands.prototype.turnAndGo = function(direction, steps, line) {
      if (line == null) {
        line = 0;
      }
      this.turn(direction, line);
      this.go(steps, line);
    };
	
    GridGameCommands.prototype.jump = function(line) {
      this.gameState.jump(this.gameState.protagonist, line);
    };

    GridGameCommands.prototype.goNorth = function(steps, line) {
      return this.turnAndGo(0, steps, line);
    };

    GridGameCommands.prototype.goEast = function(steps, line) {
      return this.turnAndGo(1, steps, line);
    };

    GridGameCommands.prototype.goSouth = function(steps, line) {
      return this.turnAndGo(2, steps, line);
    };

    GridGameCommands.prototype.goWest = function(steps, line) {
      return this.turnAndGo(3, steps, line);
    };

    GridGameCommands.prototype.mysteryGo = function(line) {
      return this.goEast(4, line);
    };
	
    GridGameCommands.prototype.mysteryMove = function(line) {
      return this.goWest(2, line);
    };

    return GridGameCommands;

  })();

}).call(this);
